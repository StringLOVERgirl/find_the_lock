<!DOCTYPE html>
<html lang="en">
<!-- preloading -->
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        * {
            padding: 0;
            margin: 0;
        }
         .mini-game {
            /* background-color: greenyellow; */
            /* height: 100vh; */
            /* width: 100vw; */
         }

         .item {
            position: absolute;
            height: 24vh;
            aspect-ratio: 10/10;
            top:var(--top);
            left:var(--left);
            z-index: -1;
            /* border: solid 1px red; */
            pointer-events: none;
         }

         @media (max-width:600px) {
            .item {
                height: 15vh;
            }
         }
         body { 
            background-color: greenyellow;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
         }

         .showOn {
            animation: glitch 0.2s 3s ease-out forwards,    
             dissapear 0.7s 3.2s ease-out forwards;
 
            /* z-index: 1; */

         }

         @keyframes glitch {
            from {}
            50% {
                filter: brightness(200%);
            }
            to {            z-index: 1;
}
         }

   
         
         @keyframes dissapear {
            from {
                transform: translateZ(0)
            }

            50% {
                opacity: 0.5;
            }

            to {
                transform: translateZ(0) translateY(-25%);
                opacity: 0;
                pointer-events: none;
            }
            
         }

         h1 {
            color: white;
            font-family: Arial, Helvetica, sans-serif;
            font-size: 4em;
            position: absolute;
            pointer-events: none;
            text-shadow: 1em 1em 10px greenyellow;
            z-index: 2;
            overflow: visible;
         }



    </style>
</head>

<body>
    <!-- <canvas></canvas> -->
    <h1 class="task">find the lock</h1>
    <canvas class="mini-game"></canvas>
    <!-- <img src="../../pngtree-salon-logo-png-image_4004444.png" alt="" > -->
    <!-- <video class="item" src="./assets/bag.webm" muted autoplay loop></video> -->
</body>

</html>

<script>

    // let item = document.querySelector('.item')
    let game = document.querySelector('.mini-game')
    let context = game.getContext('2d')

    let cursor = {
    x:0,
    y:0
}

const canvasMetrics = {
    x:undefined,
    y:undefined
}

    const flags = {
        trigger: false,
        resizeFlag: false
    }

    const itemTrigger = {
    
        x:0,
    y:0

}

    const items = [

        [
            './assets/bag.webm',
            './assets/beer.webm',
            './assets/clock.webm',
            './assets/dice.webm',
            './assets/drink.webm',
            './assets/gold.webm',
            './assets/lock.webm',
            './assets/phone.webm',
            './assets/tape.webm',

            './assets/Front(1).mp4',
            './assets/Front(2).mp4',
            './assets/Front(3).mp4',
            './assets/Front(4).mp4',
            './assets/Front.mp4'
        ],

       [
            './assets/06_3D_BTCFlower.png',
            './assets/08_3D_Receipt.png',
            './assets/11_3D_Column.png',
            './assets/Lifestyle_04.png'
        ]

]


function generateNumber(min,max){
    let number = Math.floor(Math.random() * (max - min + 1)) + min
    return number
}

    const positiongenerator = () => {

        let maxX = game.width - item.clientWidth
        let maxY = game.height - item.clientHeight
        let offsetX = generateNumber(0, maxX)
        // Math.floor(Math.random() * (maxX - 0 + 1)) + 0;
        let offsetY = generateNumber(0, maxY)
        // Math.floor(Math.random() * (maxY - 0 + 1))  0;
        document.documentElement.style.setProperty('--left',offsetX+'px')
        document.documentElement.style.setProperty('--top',offsetY+'px')

    }

    function addItem() {

        const types = ['video', 'img']
        let type = generateNumber(0, types.length - 1) // тип элемента

        let element = document.createElement(types[type])
        element.classList.add('item')

        if (type == 0) {
            let src = generateNumber(0, items[0].length - 1)
            element.src = items[0][src]
            element.autoplay = true;

// Отключаем звук (ОБЯЗАТЕЛЬНО для автовоспроизведения в большинстве браузеров)
element.muted = true;

// Зацикливаем видео
element.loop = true;
        } else {
            let src = generateNumber(0, items[1].length - 1)
            element.src = items[1][src]        }

        document.body.append(element)

    }

    function setTriggerDistance(){

        let itemrect = item.getBoundingClientRect()
        
        itemTrigger.x = itemrect.left 
        itemTrigger.y = itemrect.top 

    }



    function setCanvasSize() {

game.width = window.innerWidth
game.height = window.innerHeight

} 

setCanvasSize()

addItem()

let item = document.querySelector('.item')

positiongenerator()

setTriggerDistance()



window.addEventListener('resize', () => {
    const oldWidth = game.width;
    const oldHeight = game.height;

    // // Сохраняем содержимое как изображение
    const imageData = context.getImageData(0, 0, oldWidth, oldHeight);

    const newWidth = window.innerWidth;
    const newHeight = window.innerHeight;


    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = oldWidth;
    tempCanvas.height = oldHeight;
    tempCtx.putImageData(imageData, 0, 0);



    setCanvasSize()

    positiongenerator()
    

    setTriggerDistance()

    context.drawImage(tempCanvas, 0, 0, oldWidth, oldHeight,
     0, 0, newWidth , newHeight)

})



game.addEventListener('mousemove', (e)=>{
    let rect = game.getBoundingClientRect()
    canvasMetrics.x = e.clientX - rect.left
    canvasMetrics.y = e.clientY - rect.top

     cursor.x = e.clientX
     cursor.y = e.clientY
})


game.addEventListener('touchmove', (e) => {
    e.preventDefault(); // отключаем прокрутку при свайпе

    const touch = e.touches[0];
    let rect = game.getBoundingClientRect();

    canvasMetrics.x = touch.clientX - rect.left;
    canvasMetrics.y = touch.clientY - rect.top;

    cursor.x = touch.clientX;
    cursor.y = touch.clientY;
}, { passive: false });


context.fillRect(0,0, game.width, game.height)
context.fillStyle = 'rgba(0, 0, 0, 0)'



function fillField() {

    if (canvasMetrics.x){
    context.clearRect(canvasMetrics.x - 30,
    canvasMetrics.y - 30,
    60, 60)}

    if (cursor.x > itemTrigger.x && 
    cursor.y > itemTrigger.y &&
    cursor.x < itemTrigger.x + item.clientWidth &&
    cursor.y < itemTrigger.y + item.clientHeight&&
      !flags.trigger) {
        flags.trigger = !flags.trigger
        item.classList.add('showOn')
    } 



    requestAnimationFrame(fillField)
} fillField()
    
</script>





<!-- <script>

    let canvas = document.querySelector('canvas')
    let context = canvas.getContext('2d')

    function setCanvasSize() {

        canvas.width = window.innerWidth
        canvas.height = window.innerHeight

    } setCanvasSize()

    window.addEventListener('resize', () => {
        setCanvasSize()
        setWave()
    })

    canvas.addEventListener('mousemove', drawCircle)

    let mousex, mousey

    function drawCircle(e) {

        let rect = canvas.getBoundingClientRect()

        mousex = e.clientX - rect.left
        mousey = e.clientY - rect.top

        console.log(mousex, mousey)
    }




    let start
    let L = 200 / 3.14

    function setWave() {

        y = canvas.height / 2
        start = canvas.width / 2

    }

    setWave()

    let time = 0

    console.log(start)

     context.fillStyle = 'greenyellow'


    function s() {
// при ресайзе канвас автоматически очищает холст 
// и те пиксели которые были становятя черные
// поседняя операция фил заливает весь канвас 
// и при ресайзе он очистится и весь фил 
// т е его зона - станет черным (весь канвас в данном случае)
// или просто меняется цвет заливки 
        context.fillStyle = 'greenyellow'
        context.globalCompositeOperation = "destination-over";
console.log(context.fillStyle)


        // context.restore() // Первый restore() извлечет единственное 
        // сохраненное состояние из стека и применит его. Стек станет пустым.
        // поэтрму в цикле не сработает
        context.clearRect(0, 0, canvas.width, canvas.height)
        context.beginPath();

        //   context.moveTo(start, y) 
        // переместили  в цикл при первой итерации потому что 
        // 
        console.log(y)

        for (let x = start; x < canvas.width; x++) {

            let sin = Math.sin(x / L + time) * 100
            if (x == start) {
                context.moveTo(start, y + sin)
            }
            context.lineTo(x, y + sin)
        }

        time += 0.04


        context.strokeStyle = 'red'
        context.stroke()
        // context.closePath()
        //  линия не замыкается (волна)

        if (mousex && mousey) {

            context.save()
            console.log('circle')
            context.beginPath() //Перед рисованием каждой отдельной фигуры,
            // которая должна быть независимой от предыдущих.
            context.globalCompositeOperation = "source-over";
            // дефолт - накладываются порвех а не под 

            context.strokeStyle = 'gray'
            context.arc(mousex, mousey, 10, 0, 2 * Math.PI)
            context.fill()
            context.stroke()

            //  context.closePath() //пытается завершить текущий путь, соединяя 
            //текущую точку с начальной точкой этого пути прямой линией.
            // не обяхателен для линий и кругов и там где есть context.fill
            // тут не нужен
            context.restore()
        }
        // context.fillRect(0, 0, canvas.width, canvas.height)


        requestAnimationFrame(s)
    }
    s()

</script> -->
